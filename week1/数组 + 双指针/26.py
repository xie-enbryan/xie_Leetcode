# 输入： 非严格递增排列 的数组 nums
# 输出：返回删除后数组的新长度。
# 要求： 原地 删除重复出现的元素， 元素的 相对顺序 应该保持 一致 。

# 整体思路，拿出前一个值，依次与后面的值做比较，如果相同，就移除后面的值，
def remove_duplicate_item (nums: list)-> int:
    # 还是要用到双指针
    j = 1
    for i in range(len(nums)): # 第一次遍历，从0开始，取第一个值，一直到最后一个值
        if j < len(nums): # 防止j出界
            for j in range(len(nums)): #第二个遍历，从第二个值开始，一直到最后一个值
                if nums[i] == nums [j]: # 判断取出来的值，与第二次遍历的值依次比较，如果相等，就移除这个位置的这个值，
                    nums.pop(j)
        j+=1 # 一轮循环结束，i要自加1， 同理j也要自己加1
    return len(nums)


# 伪代码，注意这个数组是有序 的数组，“非严格递增排列 的数组 nums”
def removeDuplicate(nums: list) -> int:
    # 先把第一个值的位置用变量 i 记住，i=0，开始时
    # 然后第二个值依次与后面的值进行比较，那么就用j=1开始，然后遍历整个数组
        #如果当前的nums[i] 和nums[j] 不相等时
        # 表明它们不是重复元素，那么我的我就要把这个nums[j]记录下来，记在索引i的后一位，保证相对顺序一致
        # 即 i+=1， i往后移一位，同时nums[j]的值，赋值给nums[i]
    #一直这样做，直到整个数组遍历完
    # 最后要求我们返回删除后数组的新长度，此时i指向的是最后一个索引，那么长度应该是i+1
    i =0
    for j in range(1, len(nums)):
        if nums[i] != nums[j]:
            i+=1
            nums[i] = nums[j]

    return i+1

# 进行思维扩展，这道题考虑的是有序递增的数组，如果我给一个无序递增的数组呢？
def remove_Duplicate_unsequence_list (nums: list) -> int:
    # 同样的思路，也是拿一个元素出来，依次与后面的元素比较
    # 取第一个元素 i =0, 用第一个索引值，取第一个元素
    # 也是一样开始，遍历整个数列，依次与拿出来的第一个比较
        # 如果不同的话，nums[i] 不等于nums[j]
        # 用set集合添加，nums[j]
        # 如果相同的话，nums[i]=nums[j]
        # 相同情况，不知道怎么处理了？


    # 比较完一轮后，i+1，然后用第二个元素，依次与后面的比较，也就是j也要+1， 进行第二轮遍历
    pass


